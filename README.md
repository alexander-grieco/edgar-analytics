# Edgar Analytics Solution

See the prompt for this problem [here](https://github.com/InsightDataScience/edgar-analytics)

The idea of my solution is to use two dictionaries. The first, is a two level ordered dictionary (sessionBoundsDict) where the key of the first level is the start time of an active session and the value is dictionary object with the ip address of the user as key and the value is the time of the last request for that session. The idea here is to create quick lookups by time first and then by ip. The reason I have used an ordered dictionary, is that we are supposed to flush all remaining sessions (when the input file ends) in order of start time of the session. This is also why I have chosen start time as the key in the first level of the dictionary.

For my second dictionary I am creating an unordered dictionary (activeSessionDict) with ip as the key and a session object as the value. The use of this dictionary is that it makes writing to output easy. The session object has a method which writes all the necessary information to output.

The general idea of my solution is to read in a request line from the input file, if the ip of the user belongs to an active session, that session is updated with the current time as the last request time, and the number of documents in the session is incremented by one. Also the last time of the session object in the activeSessionDict is updated. If the ip is not in an active session then a new session object is created and added to activeSessionDict and the information is added to the sessionBoundsDict. If the datetime has progressed, then I check if any of the old sessions have completed (i.e. they are out of the bounds of the inactivity period). If a session has gone beyond the inactivity period, then I write the sessions information to the output file. Finally, once the input file has finished processing, I flush all remaining active sessions to the output file in order of their session start time.
